import type {
    ContainerCreateOptions,
    ContainerProviderConnection,
    DeviceRequest,
    ImageInfo,
    MountConfig,
    ProviderContainerConnection,
} from '@podman-desktop/api';

import * as extensionApi from '@podman-desktop/api';
import type { PodmanConnection } from '../../managers/podmanConnection';
import * as PodmanConnectionAPI from '../../managers/podmanConnection';
import { containerEngine, provider, ProgressLocation } from '@podman-desktop/api';

export const SECOND: number = 1_000_000_000;

const path = require('path');
const fs = require('fs');
const async_fs = require('fs/promises');

const AvailableModels = {};
let ExtensionStoragePath = undefined;

const FAIL_IF_NOT_MAC = true;
const SHOW_INITIAL_MENU = true;
const SHOW_MODEL_SELECT_MENU = true;
const EXTENSION_BUILD_PATH = path.parse(__filename).dir + "/../build";

const DEFAULT_MODEL_NAME = "ibm-granite/granite-3.3-8b-instruct-GGUF"; // if not showing the select menu
let RamalamaRemotingImage = undefined;
let ApirVersion = undefined;
let LocalBuildDir = undefined;

const MAIN_MENU_CHOICES = {
    'Restart PodMan Machine with API Remoting support': () => restart_podman_machine_with_apir(),
    'Restart PodMan Machine with the default configuration': () => restart_podman_machine_without_apir(),
    'Launch an API Remoting accelerated Inference Server': () => launchApirInferenceServer(),
    'Check  PodMan Machine API Remoting status': () => checkPodmanMachineStatus(true),
}

function registerFromDir(startPath, filter, register) {
    if (!fs.existsSync(startPath)) {
        console.log("no dir ", startPath);
        return;
    }

    var files = fs.readdirSync(startPath);
    for (var i = 0; i < files.length; i++) {
        var filename = path.join(startPath, files[i]);
        var stat = fs.lstatSync(filename);
        if (stat.isDirectory()) {
            registerFromDir(filename, filter, register); //recurse
        } else if (filename.endsWith(filter)) {
            register(filename);
        };
    };
};

// generated by chatgpt
async function copyRecursive(src, dest) {
  const entries = await async_fs.readdir(src, { withFileTypes: true });

  await async_fs.mkdir(dest, { recursive: true });

  for (let entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);

    if (entry.isDirectory()) {
      await copyRecursive(srcPath, destPath);
    } else {
      await async_fs.copyFile(srcPath, destPath);
    }
  }
}

const getRandomString = (): string => {
  // eslint-disable-next-line sonarjs/pseudo-random
  return (Math.random() + 1).toString(36).substring(7);
};

function refreshAvailableModels() {
    if (ExtensionStoragePath === undefined) throw new Error('ExtensionStoragePath not defined :/');

    // delete the existing models
    Object.keys(AvailableModels).forEach(key => delete AvailableModels[key]);

    const registerModel = function(filename) {
        const dir_name = filename.split("/").at(-2)
        const name_parts = dir_name.split(".")
        // 0 is the source (eg, hf)
        const model_dir = name_parts.at(1)
        const model_name = name_parts.slice(2).join('.')
        const model_user_name = `${model_dir}/${model_name}`
        AvailableModels[model_user_name] = filename;
        console.log(`found ${model_user_name}`)
    }

    registerFromDir(ExtensionStoragePath + '/../redhat.ai-lab/models', '.gguf', registerModel);
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function hasApirContainerRunning() {
    const containerInfo =
          (await containerEngine.listContainers())
          .find(containerInfo => (containerInfo.Labels["llama-cpp.apir"] === "true" && containerInfo.State === "running"));

    return containerInfo?.Id;
}

async function launchApirInferenceServer() {
    const containerId = await hasApirContainerRunning();
    if (containerId !== undefined) {
        console.error(`API Remoting container ${containerId} already running ...`);
        await extensionApi.window.showErrorMessage(`API Remoting container ${containerId} is already running. This version cannot have two API Remoting containers running simultaneously.`);
        return;
    }

    if (RamalamaRemotingImage === undefined) throw new Error("Ramalama Remoting image name not loaded. This is unexpected.");

    let model_name;
    if (Object.keys(AvailableModels).length === 0) {
	await extensionApi.window.showInformationMessage(`Could not find any model downloaded from AI Lab. Please select a GGUF file to load.`);
	let model_name_uri = await extensionApi.window.showOpenDialog({tile: "Select a model file", openLabel: "Select a GGUF file", selectors:["openFile"]})

	if (model_name_uri === undefined) {
	    console.log("No model selected, aborting the APIR container launch silently.")
	    return;
	}
	model_name = model_name_uri[0].fsPath;
	if (path.extname(model_name).toLowerCase() !== '.gguf') {
	    const msg = `Selected file isn't a .gguf: ${model_name}`
            console.warn(msg);
            await extensionApi.window.showErrorMessage(msg);
	    return;
	}

	if (!fs.existsSync(model_name)){
            const msg = `Selected GGUF model file does not exist: ${model_name}`
            console.warn(msg);
            await extensionApi.window.showErrorMessage(msg);
	    return;
	}

    } else if (SHOW_MODEL_SELECT_MENU) {
        refreshAvailableModels();

        // display a choice to the user for selecting some values
        model_name = await extensionApi.window.showQuickPick(Object.keys(AvailableModels), {
            canPickMany: false, // user can select more than one choice
            title: "Choose the model to deploy",
        });
        if (model_name === undefined) {
            console.warn('No model chosen, nothing to launch.')
            return;
        }

    } else {
        model_name = DEFAULT_MODEL_NAME;
    }

    // prepare the port
    let host_port = await extensionApi.window.showInputBox({title: "Service port", prompt: "Inference service port on the host", value: "1234", validateInput: (value)=> parseInt(value, 10) > 1024 ? "": "Enter a valid port > 1024"});
    host_port = parseInt(host_port);

    if (host_port === undefined || Number.isNaN(host_port)) {
        console.warn('No host port chosen, nothing to launch.')
        return;
    }

    // pull the image
    const imageInfo: ImageInfo = await pullImage(
        RamalamaRemotingImage,
        {},
    );


    // get model mount settings
    if (Object.keys(AvailableModels).length === 0) {
	model_src = model_name;
    } else {
	model_src = AvailableModels[model_name];
    }
    if (model_src === undefined)
        throw new Error(`Couldn't get the file associated with model ${model_src}. This is unexpected.`);

    const model_filename = path.basename(model_src);
    const model_dirname = path.basename(path.dirname(model_src));
    const model_dest = `/models/${model_filename}`;
    const ai_lab_port = 10434;

    // prepare the labels
    const labels: Record<string, string> = {
        ['ai-lab-inference-server']: JSON.stringify([model_dirname]),
        ['api']: `http://localhost:${host_port}/v1`,
        ['docs']: `http://localhost:${ai_lab_port}/api-docs/${host_port}`,
        ['gpu']: `llama.cpp API Remoting`,
        ["trackingId"]: getRandomString(),
        ["llama-cpp.apir"]: "true",
    };

    // prepare the mounts
    // mount the file directory to avoid adding other files to the containers
    const mounts: MountConfig = [
      {
          Target: model_dest,
          Source: model_src,
          Type: 'bind',
      },
    ];

    // prepare the entrypoint
    let entrypoint: string | undefined = undefined;
    let cmd: string[] = [];

    entrypoint = "/usr/bin/llama-server.sh";

    // prepare the env
    const envs: string[] = [`MODEL_PATH=${model_dest}`, 'HOST=0.0.0.0', 'PORT=8000', 'GPU_LAYERS=999'];

    // prepare the devices
    const devices: Device[] = [];
    devices.push({
        PathOnHost: '/dev/dri',
        PathInContainer: '/dev/dri',
        CgroupPermissions: '',
    });

    const deviceRequests: DeviceRequest[] = [];
    deviceRequests.push({
        Capabilities: [['gpu']],
        Count: -1, // -1: all
    });

    // Get the container creation options
    const containerCreateOptions: ContainerCreateOptions = {
        Image: imageInfo.Id,
        Detach: true,
        Entrypoint: entrypoint,
        Cmd: cmd,
        ExposedPorts: { [`${host_port}`]: {} },
        HostConfig: {
            AutoRemove: false,
            Devices: devices,
            Mounts: mounts,
            DeviceRequests: deviceRequests,
            SecurityOpt: ["label=disable"],
            PortBindings: {
                '8000/tcp': [
                    {
                        HostPort: `${host_port}`,
                    },
                ],
            },
        },

        HealthCheck: {
          // must be the port INSIDE the container not the exposed one
          Test: ['CMD-SHELL', `curl -sSf localhost:8000 > /dev/null`],
          Interval: SECOND * 5,
          Retries: 4 * 5,
          },
        Labels: labels,
        Env: envs,
    };
    console.log(containerCreateOptions, mounts)
    // Create the container
    const { engineId, id } = await createContainer(imageInfo.engineId, containerCreateOptions, labels);

    await extensionApi.window.showInformationMessage(`API Remoting container ${id} has been launched!`);

}
export type BetterContainerCreateResult = ContainerCreateResult & { engineId: string };

async function createContainer(
    engineId: string,
    containerCreateOptions: ContainerCreateOptions,
    labels: { [id: string]: string },
): Promise<BetterContainerCreateResult> {

    console.log("Creating container ...");
    try {
        const result = await containerEngine.createContainer(engineId, containerCreateOptions);
        console.log("Container created!");

        // return the ContainerCreateResult
        return {
            id: result.id,
            engineId: engineId,
        };
    } catch (err: unknown) {
        const msg = `Container creation failed :/ ${String(err)}`
        console.error(msg);
        await extensionApi.window.showErrorMessage(msg);
        throw err;
    }
}

async function pullImage(
    image: string,
    labels: { [id: string]: string },
): Promise<ImageInfo> {
    // Creating a task to follow pulling progress
    console.log(`Pulling the image ${image} ...`)

    const providers: ProviderContainerConnection[] = provider.getContainerConnections();
    const podmanProvider = providers
          .filter(({ connection }) => connection.type === 'podman');
    if (!podmanProvider) throw new Error(`cannot find podman provider`);

    let connection: ContainerProviderConnection = podmanProvider[0].connection;

    // get the default image info for this provider
    return getImageInfo(connection, image, (_event: PullEvent) => {})
        .catch((err: unknown) => {
            console.error(`Something went wrong while pulling ${image}: ${String(err)}`);
            throw err;
        })
        .then(imageInfo => {
            console.log("Image pulled successfully");
            return imageInfo;
        });
}

async function getImageInfo(
  connection: ContainerProviderConnection,
  image: string,
  callback: (event: PullEvent) => void,
): Promise<ImageInfo> {
    let imageInfo = undefined;

    try {
        // Pull image
        await containerEngine.pullImage(connection, image, callback);

        // Get image inspect
        imageInfo = (
            await containerEngine.listImages({
                provider: connection,
            } as ListImagesOptions)
        ).find(imageInfo => imageInfo.RepoTags?.some(tag => tag === image));

    } catch (err: unknown) {
        console.warn('Something went wrong while trying to get image inspect', err);
        await extensionApi.window.showErrorMessage(`Something went wrong while trying to get image inspect: ${err}`);

        throw err;
    }

    if (imageInfo === undefined) throw new Error(`image ${image} not found.`);

    return imageInfo;
}

async function initializeBuildDir(buildPath) {
    console.log(`Initializing the build directory from ${buildPath} ...`)

    ApirVersion = (await async_fs.readFile(buildPath + '/src_info/version.txt', 'utf8')).replace(/\n$/, "");

    if (RamalamaRemotingImage === undefined)
        RamalamaRemotingImage = (await async_fs.readFile(buildPath + '/src_info/ramalama.image-info.txt', 'utf8')).replace(/\n$/, "");
}

async function initializeStorageDir(storagePath, buildPath) {
    console.log(`Initializing the storage directory ...`)

    if (!fs.existsSync(storagePath)){
        fs.mkdirSync(storagePath);
    }

    if (ApirVersion === undefined) throw new Error("APIR version not loaded. This is unexpected.");

    LocalBuildDir = `${storagePath}/${ApirVersion}`;
    if (!fs.existsSync(LocalBuildDir)){
        copyRecursive(buildPath, LocalBuildDir)
            .then(() => console.log('Copy complete'));
    }
}

export async function activate(extensionContext: extensionApi.ExtensionContext): Promise<void> {
    // initialize the global variables ...
    ExtensionStoragePath = extensionContext.storagePath;
    console.log("Activating the API Remoting extension ...")
    try {
        await initializeBuildDir(EXTENSION_BUILD_PATH);
        console.log(`Installing APIR version ${ApirVersion} ...`);
        console.log(`Using image ${RamalamaRemotingImage}`);

        await initializeStorageDir(extensionContext.storagePath, EXTENSION_BUILD_PATH);

        console.log(`Preparing the krunkit binaries ...`);
        await prepare_krunkit();

        console.log(`Loading the models ...`);
        refreshAvailableModels();
    } catch (error) {
        const msg = `Couldn't initialize the extension: ${error}`

        await extensionApi.window.showErrorMessage(msg);
        // throw new Error(msg);
    }

    // register the command referenced in package.json file
    const menuCommand = extensionApi.commands.registerCommand('llama.cpp.apir.menu', async () => {
        if (FAIL_IF_NOT_MAC && !extensionApi.env.isMac) {
            await extensionApi.window.showErrorMessage(`llama.cpp API Remoting only supported on MacOS.`);
            return;
        }

        let result;
        if (SHOW_INITIAL_MENU) {
            // display a choice to the user for selecting some values
            result = await extensionApi.window.showQuickPick(Object.keys(MAIN_MENU_CHOICES), {
                title: "What do you want to do?",
                canPickMany: false, // user can select more than one choice
            });
        } else {
            result = MAIN_MENU_CHOICES[2];
        }

        if (result === undefined) {
            console.log("No user choice, aborting.");
            return;
        }

        try {
            MAIN_MENU_CHOICES[result]();
        } catch (error) {
            const msg = `Task failed: ${String(error)}`;
            console.error(msg);
            await extensionApi.window.showErrorMessage(msg);

            throw err;
        }
    });

    try {
        // create an item in the status bar to run our command
        // it will stick on the left of the status bar
        const item = extensionApi.window.createStatusBarItem(extensionApi.StatusBarAlignLeft, 100);
        item.text = 'Llama.cpp API Remoting';
        item.command = 'llama.cpp.apir.menu';
        item.show();

        // register disposable resources to it's removed when you deactivte the extension
        extensionContext.subscriptions.push(menuCommand);
        extensionContext.subscriptions.push(item);
    } catch (error) {
        const msg = `Couldn't subscribe the extension to Podman Desktop: ${error}`

        await extensionApi.window.showErrorMessage(msg);
        throw new Error(msg);
    }
}

export async function deactivate(): Promise<void> {

}

async function restart_podman_machine_with_apir(): Promise<void> {
    if (LocalBuildDir === undefined) throw new Error("LocalBuildDir not loaded. This is unexpected.");

    await extensionApi.window.showInformationMessage(`Restarting Podman machine with APIR support ...`);

    try {
        const { stdout } = await extensionApi.process.exec("/usr/bin/env", ["bash", `${LocalBuildDir}/podman_start_machine.api_remoting.sh`], {cwd: LocalBuildDir});

        const msg = "Podman machine successfully restarted with the APIR libraries"
        await extensionApi.window.showInformationMessage(msg);
        console.log(msg);
    } catch (error) {
        const msg = `Failed to restart podman machine with the API libraries: ${error}`
        await extensionApi.window.showErrorMessage(msg);
        console.error(msg);
        throw new Error(msg);
    }
}

async function restart_podman_machine_without_apir(): Promise<void> {
    await extensionApi.window.showInformationMessage(`Restarting Podman machine without API Remoting support`);

    try {
        console.log(`Stopping the PodMan Machine ...`);
        const { stdout } = await extensionApi.process.exec("podman", ['machine', 'stop']);
    } catch (error) {
        const msg = `Failed to stop the PodMan Machine: ${error}`;
        await extensionApi.window.showErrorMessage(msg);
        console.error(msg);
        throw new Error(msg);
    }

    try {
        console.log(`Starting the PodMan Machine ...`);
        const { stdout } = await extensionApi.process.exec("podman", ['machine', 'start']);
    } catch (error) {
        const msg = `Failed to restart the PodMan Machine: ${error}`;
        await extensionApi.window.showErrorMessage(msg);
        console.error(msg);
        throw new Error(msg);
    }

    const msg = "PodMan Machine successfully restarted without API Remoting support";
    await extensionApi.window.showInformationMessage(msg);
    console.error(msg);
}

async function prepare_krunkit(): Promise<void> {
    if (LocalBuildDir === undefined) throw new Error("LocalBuildDir not loaded. This is unexpected.");

    if (fs.existsSync(`${LocalBuildDir}/bin/krunkit`)) {
        console.log("Binaries already prepared.")
        return;
    }

    await extensionApi.window.showInformationMessage(`Preparing the krunkit binaries for API Remoting ...`);

    try {
        const { stdout } = await extensionApi.process.exec("/usr/bin/env", ["bash", `${LocalBuildDir}/update_krunkit.sh`], {cwd: LocalBuildDir});
    } catch (error) {
        console.error(error);
        throw new Error(`Couldn't update the krunkit binaries: ${error}: ${error.stdout}`);
    }
    await extensionApi.window.showInformationMessage(`Binaries successfully prepared!`);

    console.log("Binaries successfully prepared!")
}

async function checkPodmanMachineStatus(with_gui): Promise<void> {
    try {
        const { stdout } = await extensionApi.process.exec("/usr/bin/env", ["bash", `${EXTENSION_BUILD_PATH}/check_podman_machine_status.sh`], {cwd: LocalBuildDir});
        // exit with success, krunkit is running API remoting
        const status = stdout.replace(/\n$/, "")
        const msg = `Podman Machine API Remoting status:\n${status}`
        if (with_gui) {
            await extensionApi.window.showInformationMessage(msg);
        }
        console.log(msg);

        return 0;
    } catch (error) {
        //console.error(error);
        let msg;
        const status = error.stdout.replace(/\n$/, "")
        const exitCode = error.exitCode;

        if (exitCode > 10 && exitCode < 20) {
            // exit with code 1x ==> successful completion, but not API Remoting support
            msg =`Podman Machine status: ${status}: status #${exitCode}`;
            if (with_gui) {
                await extensionApi.window.showErrorMessage(msg);
            }
            console.warn(msg)
            return exitCode;
        }

        // other exit code crash of unsuccessful completion
        msg =`Failed to check PodMan Machine status: ${status} (code #${exitCode})`;
        await extensionApi.window.showErrorMessage(msg);
        console.error(msg);
        throw new Error(msg);
    }
}
